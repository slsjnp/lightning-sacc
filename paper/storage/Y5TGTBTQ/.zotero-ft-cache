arXiv:2010.04159v2 [cs.CV] 30 Nov 2020

DEFORMABLE DETR: DEFORMABLE TRANSFORMERS FOR END-TO-END OBJECT DETECTION
Xizhou Zhu1‚àó, Weijie Su2‚àó‚Ä†, Lewei Lu1, Bin Li2, Xiaogang Wang1,3, Jifeng Dai1 1SenseTime Research 2University of Science and Technology of China 3The Chinese University of Hong Kong {zhuwalter,luotto,daijifeng}@sensetime.com jackroos@mail.ustc.edu.cn, binli@ustc.edu.cn xgwang@ee.cuhk.edu.hk
ABSTRACT
DETR has been recently proposed to eliminate the need for many hand-designed components in object detection while demonstrating good performance. However, it suffers from slow convergence and limited feature spatial resolution, due to the limitation of Transformer attention modules in processing image feature maps. To mitigate these issues, we proposed Deformable DETR, whose attention modules only attend to a small set of key sampling points around a reference. Deformable DETR can achieve better performance than DETR (especially on small objects) with 10√ó less training epochs. Extensive experiments on the COCO benchmark demonstrate the effectiveness of our approach. Code is released at https:// github.com/fundamentalvision/Deformable-DETR.
1 INTRODUCTION
Modern object detectors employ many hand-crafted components (Liu et al., 2020), e.g., anchor generation, rule-based training target assignment, non-maximum suppression (NMS) post-processing. They are not fully end-to-end. Recently, Carion et al. (2020) proposed DETR to eliminate the need for such hand-crafted components, and built the Ô¨Årst fully end-to-end object detector, achieving very competitive performance. DETR utilizes a simple architecture, by combining convolutional neural networks (CNNs) and Transformer (Vaswani et al., 2017) encoder-decoders. They exploit the versatile and powerful relation modeling capability of Transformers to replace the hand-crafted rules, under properly designed training signals.
Despite its interesting design and good performance, DETR has its own issues: (1) It requires much longer training epochs to converge than the existing object detectors. For example, on the COCO (Lin et al., 2014) benchmark, DETR needs 500 epochs to converge, which is around 10 to 20 times slower than Faster R-CNN (Ren et al., 2015). (2) DETR delivers relatively low performance at detecting small objects. Modern object detectors usually exploit multi-scale features, where small objects are detected from high-resolution feature maps. Meanwhile, high-resolution feature maps lead to unacceptable complexities for DETR. The above-mentioned issues can be mainly attributed to the deÔ¨Åcit of Transformer components in processing image feature maps. At initialization, the attention modules cast nearly uniform attention weights to all the pixels in the feature maps. Long training epoches is necessary for the attention weights to be learned to focus on sparse meaningful locations. On the other hand, the attention weights computation in Transformer encoder is of quadratic computation w.r.t. pixel numbers. Thus, it is of very high computational and memory complexities to process high-resolution feature maps.
In the image domain, deformable convolution (Dai et al., 2017) is of a powerful and efÔ¨Åcient mechanism to attend to sparse spatial locations. It naturally avoids the above-mentioned issues. While it lacks the element relation modeling mechanism, which is the key for the success of DETR.
‚àóEqual contribution. ‚Ä† This work is done when Weijie Su is an intern at SenseTime Research.
1

Multi-scale Deformable Self-Attention in Encoder
Multi-scale Deformable Cross-Attention in Decoder
Transformer Self-Attention in Decoder

Multi-scale Feature Maps

Image Feature Maps √ó4

Bounding Box Predictions √ó4

Image

Encoder

Decoder Object Queries

Figure 1: Illustration of the proposed Deformable DETR object detector.

In this paper, we propose Deformable DETR, which mitigates the slow convergence and high complexity issues of DETR. It combines the best of the sparse spatial sampling of deformable convolution, and the relation modeling capability of Transformers. We propose the deformable attention module, which attends to a small set of sampling locations as a pre-Ô¨Ålter for prominent key elements out of all the feature map pixels. The module can be naturally extended to aggregating multi-scale features, without the help of FPN (Lin et al., 2017a). In Deformable DETR , we utilize (multi-scale) deformable attention modules to replace the Transformer attention modules processing feature maps, as shown in Fig. 1.
Deformable DETR opens up possibilities for us to exploit variants of end-to-end object detectors, thanks to its fast convergence, and computational and memory efÔ¨Åciency. We explore a simple and effective iterative bounding box reÔ¨Ånement mechanism to improve the detection performance. We also try a two-stage Deformable DETR, where the region proposals are also generated by a vaiant of Deformable DETR, which are further fed into the decoder for iterative bounding box reÔ¨Ånement.
Extensive experiments on the COCO (Lin et al., 2014) benchmark demonstrate the effectiveness of our approach. Compared with DETR, Deformable DETR can achieve better performance (especially on small objects) with 10√ó less training epochs. The proposed variant of two-stage Deformable DETR can further improve the performance. Code is released at https://github. com/fundamentalvision/Deformable-DETR.

2 RELATED WORK
EfÔ¨Åcient Attention Mechanism. Transformers (Vaswani et al., 2017) involve both self-attention and cross-attention mechanisms. One of the most well-known concern of Transformers is the high time and memory complexity at vast key element numbers, which hinders model scalability in many cases. Recently, many efforts have been made to address this problem (Tay et al., 2020b), which can be roughly divided into three categories in practice.
The Ô¨Årst category is to use pre-deÔ¨Åned sparse attention patterns on keys. The most straightforward paradigm is restricting the attention pattern to be Ô¨Åxed local windows. Most works (Liu et al., 2018a; Parmar et al., 2018; Child et al., 2019; Huang et al., 2019; Ho et al., 2019; Hu et al., 2019; Parmar et al., 2019; Qiu et al., 2019; Beltagy et al., 2020; Ainslie et al., 2020; Zaheer et al., 2020) follow this paradigm. Although restricting the attention pattern to a local neighborhood can decrease the complexity, it loses global information. To compensate, Child et al. (2019); Huang et al. (2019); Ho et al. (2019) attend key elements at Ô¨Åxed intervals to signiÔ¨Åcantly increase the receptive Ô¨Åeld

2

on keys. Beltagy et al. (2020); Ainslie et al. (2020); Zaheer et al. (2020) allow a small number of special tokens having access to all key elements. Zaheer et al. (2020); Qiu et al. (2019) also add some pre-Ô¨Åxed sparse attention patterns to attend distant key elements directly.
The second category is to learn data-dependent sparse attention. Kitaev et al. (2020) proposes a locality sensitive hashing (LSH) based attention, which hashes both the query and key elements to different bins. A similar idea is proposed by Roy et al. (2020), where k-means Ô¨Ånds out the most related keys. Tay et al. (2020a) learns block permutation for block-wise sparse attention.
The third category is to explore the low-rank property in self-attention. Wang et al. (2020) reduces the number of key elements through a linear projection on the size dimension instead of the channel dimension. Katharopoulos et al. (2020); Choromanski et al. (2020) rewrite the calculation of selfattention through kernelization approximation.
In the image domain, the designs of efÔ¨Åcient attention mechanism (e.g., Parmar et al. (2018); Child et al. (2019); Huang et al. (2019); Ho et al. (2019); Hu et al. (2019); Parmar et al. (2019)) are still limited to the Ô¨Årst category. Despite the theoretically reduced complexity, Parmar et al. (2019); Hu et al. (2019) admit such approaches are much slower in implementation than traditional convolution with the same FLOPs (at least 3√ó slower), due to the intrinsic limitation in memory access patterns.
On the other hand, as discussed in Zhu et al. (2019a), there are variants of convolution, such as deformable convolution (Dai et al., 2017; Zhu et al., 2019b) and dynamic convolution (Wu et al., 2019), that also can be viewed as self-attention mechanisms. Especially, deformable convolution operates much more effectively and efÔ¨Åciently on image recognition than Transformer self-attention. Meanwhile, it lacks the element relation modeling mechanism.
Our proposed deformable attention module is inspired by deformable convolution, and belongs to the second category. It only focuses on a small Ô¨Åxed set of sampling points predicted from the feature of query elements. Different from Parmar et al. (2019); Hu et al. (2019), deformable attention is just slightly slower than the traditional convolution under the same FLOPs.
Multi-scale Feature Representation for Object Detection. One of the main difÔ¨Åculties in object detection is to effectively represent objects at vastly different scales. Modern object detectors usually exploit multi-scale features to accommodate this. As one of the pioneering works, FPN (Lin et al., 2017a) proposes a top-down path to combine multi-scale features. PANet (Liu et al., 2018b) further adds an bottom-up path on the top of FPN. Kong et al. (2018) combines features from all scales by a global attention operation. Zhao et al. (2019) proposes a U-shape module to fuse multi-scale features. Recently, NAS-FPN (Ghiasi et al., 2019) and Auto-FPN (Xu et al., 2019) are proposed to automatically design cross-scale connections via neural architecture search. Tan et al. (2020) proposes the BiFPN, which is a repeated simpliÔ¨Åed version of PANet. Our proposed multi-scale deformable attention module can naturally aggregate multi-scale feature maps via attention mechanism, without the help of these feature pyramid networks.

3 REVISITING TRANSFORMERS AND DETR

Multi-Head Attention in Transformers. Transformers (Vaswani et al., 2017) are of a network architecture based on attention mechanisms for machine translation. Given a query element (e.g., a target word in the output sentence) and a set of key elements (e.g., source words in the input sentence), the multi-head attention module adaptively aggregates the key contents according to the attention weights that measure the compatibility of query-key pairs. To allow the model focusing on contents from different representation subspaces and different positions, the outputs of different attention heads are linearly aggregated with learnable weights. Let q ‚àà ‚Ñ¶q indexes a query element with representation feature zq ‚àà RC , and k ‚àà ‚Ñ¶k indexes a key element with representation feature xk ‚àà RC , where C is the feature dimension, ‚Ñ¶q and ‚Ñ¶k specify the set of query and key elements, respectively. Then the multi-head attention feature is calculated by

M

MultiHeadAttn(zq, x) = Wm

Amqk ¬∑ Wmxk ,

(1)

m=1

k‚àà‚Ñ¶k

where m indexes the attention head, Wm ‚àà RCv√óC and Wm ‚àà RC√óCv are of learnable weights

(Cv

=

C/M

by default).

The attention weights Amqk

‚àù

exp{ zqT U‚àöm T Vmxk }
Cv

are

normalized

as

3

k‚àà‚Ñ¶k Amqk = 1, in which Um, Vm ‚àà RCv√óC are also learnable weights. To disambiguate different spatial positions, the representation features zq and xk are usually of the concatenation/summation of element contents and positional embeddings.

There are two known issues with Transformers. One is Transformers need long training schedules

before convergence. Suppose the number of query and key elements are of Nq and Nk, respectively.

Typically, with proper parameter initialization, Umzq and Vmxk follow distribution with mean of

0 and variance of 1, which makes attention weights Amqk

‚âà

1 Nk

,

when

Nk

is large.

It will lead

to ambiguous gradients for input features. Thus, long training schedules are required so that the

attention weights can focus on speciÔ¨Åc keys. In the image domain, where the key elements are

usually of image pixels, Nk can be very large and the convergence is tedious.

On the other hand, the computational and memory complexity for multi-head attention can be
very high with numerous query and key elements. The computational complexity of Eq. 1 is of O(NqC2 + NkC2 + NqNkC). In the image domain, where the query and key elements are both of pixels, Nq = Nk C, the complexity is dominated by the third term, as O(NqNkC). Thus, the multi-head attention module suffers from a quadratic complexity growth with the feature map size.

DETR. DETR (Carion et al., 2020) is built upon the Transformer encoder-decoder architecture, combined with a set-based Hungarian loss that forces unique predictions for each ground-truth bounding box via bipartite matching. We brieÔ¨Çy review the network architecture as follows.
Given the input feature maps x ‚àà RC√óH√óW extracted by a CNN backbone (e.g., ResNet (He et al., 2016)), DETR exploits a standard Transformer encoder-decoder architecture to transform the input feature maps to be features of a set of object queries. A 3-layer feed-forward neural network (FFN) and a linear projection are added on top of the object query features (produced by the decoder) as the detection head. The FFN acts as the regression branch to predict the bounding box coordinates b ‚àà [0, 1]4, where b = {bx, by, bw, bh} encodes the normalized box center coordinates, box height and width (relative to the image size). The linear projection acts as the classiÔ¨Åcation branch to produce the classiÔ¨Åcation results.

For the Transformer encoder in DETR, both query and key elements are of pixels in the feature maps.
The inputs are of ResNet feature maps (with encoded positional embeddings). Let H and W denote
the feature map height and width, respectively. The computational complexity of self-attention is of O(H2W 2C), which grows quadratically with the spatial size.

For the Transformer decoder in DETR, the input includes both feature maps from the encoder, and N object queries represented by learnable positional embeddings (e.g., N = 100). There are two
types of attention modules in the decoder, namely, cross-attention and self-attention modules. In the
cross-attention modules, object queries extract features from the feature maps. The query elements
are of the object queries, and key elements are of the output feature maps from the encoder. In it, Nq = N , Nk = H √ó W and the complexity of the cross-attention is of O(HW C2 + N HW C). The complexity grows linearly with the spatial size of feature maps. In the self-attention modules,
object queries interact with each other, so as to capture their relations. The query and key elements are both of the object queries. In it, Nq = Nk = N , and the complexity of the self-attention module is of O(2N C2 + N 2C). The complexity is acceptable with moderate number of object queries.

DETR is an attractive design for object detection, which removes the need for many hand-designed components. However, it also has its own issues. These issues can be mainly attributed to the deÔ¨Åcits of Transformer attention in handling image feature maps as key elements: (1) DETR has relatively low performance in detecting small objects. Modern object detectors use high-resolution feature maps to better detect small objects. However, high-resolution feature maps would lead to an unacceptable complexity for the self-attention module in the Transformer encoder of DETR, which has a quadratic complexity with the spatial size of input feature maps. (2) Compared with modern object detectors, DETR requires many more training epochs to converge. This is mainly because the attention modules processing image features are difÔ¨Åcult to train. For example, at initialization, the cross-attention modules are almost of average attention on the whole feature maps. While, at the end of the training, the attention maps are learned to be very sparse, focusing only on the object extremities. It seems that DETR requires a long training schedule to learn such signiÔ¨Åcant changes in the attention maps.

4

4 METHOD

4.1 DEFORMABLE TRANSFORMERS FOR END-TO-END OBJECT DETECTION

Deformable Attention Module. The core issue of applying Transformer attention on image feature maps is that it would look over all possible spatial locations. To address this, we present a deformable attention module. Inspired by deformable convolution (Dai et al., 2017; Zhu et al., 2019b), the deformable attention module only attends to a small set of key sampling points around a reference point, regardless of the spatial size of the feature maps. By assigning only a small Ô¨Åxed number of keys for each query, the issues of convergence and feature spatial resolution can be mitigated.

Given an input feature map x ‚àà RC√óH√óW , let q index a query element with content feature zq and a 2-d reference point pq, the deformable attention feature is calculated by

M

K

DeformAttn(zq, pq, x) = Wm Amqk ¬∑ Wmx(pq + ‚àÜpmqk) ,

(2)

m=1

k=1

where m indexes the attention head, k indexes the sampled keys, and K is the total sampled key

number (K HW ). ‚àÜpmqk and Amqk denote the sampling offset and attention weight of the

kth sampling point in the mth attention head, respectively. The scalar attention weight Amqk lies

in the range [0, 1], normalized by

K k=1

Amqk

=

1.

‚àÜpmqk

‚àà

R2

are of 2-d real numbers with

unconstrained range. As pq + ‚àÜpmqk is fractional, bilinear interpolation is applied as in Dai et al.

(2017) in computing x(pq +‚àÜpmqk). Both ‚àÜpmqk and Amqk are obtained via linear projection over

the query feature zq. In implementation, the query feature zq is fed to a linear projection operator

of 3M K channels, where the Ô¨Årst 2M K channels encode the sampling offsets ‚àÜpmqk, and the

remaining M K channels are fed to a softmax operator to obtain the attention weights Amqk.

The deformable attention module is designed for processing convolutional feature maps as key ele-
ments. Let Nq be the number of query elements, when M K is relatively small, the complexity of the deformable attention module is of O(2NqC2 + min(HW C2, NqKC2)) (See Appendix A.1 for details). When it is applied in DETR encoder, where Nq = HW , the complexity becomes O(HW C2), which is of linear complexity with the spatial size. When it is applied as the cross-attention modules
in DETR decoder, where Nq = N (N is the number of object queries), the complexity becomes O(N KC2), which is irrelevant to the spatial size HW .

Multi-scale Deformable Attention Module. Most modern object detection frameworks beneÔ¨Åt from multi-scale feature maps (Liu et al., 2020). Our proposed deformable attention module can be naturally extended for multi-scale feature maps.
Let {xl}Ll=1 be the input multi-scale feature maps, where xl ‚àà RC√óHl√óWl . Let pÀÜq ‚àà [0, 1]2 be the normalized coordinates of the reference point for each query element q, then the multi-scale deformable attention module is applied as

M

LK

MSDeformAttn(zq, pÀÜq, {xl}Ll=1) = Wm

Amlqk ¬∑ Wmxl(œÜl(pÀÜq) + ‚àÜpmlqk) , (3)

m=1

l=1 k=1

where m indexes the attention head, l indexes the input feature level, and k indexes the sampling

point. ‚àÜpmlqk and Amlqk denote the sampling offset and attention weight of the kth sampling point

in the lth feature level and the mth attention head, respectively. The scalar attention weight Amlqk

is normalized by

L l=1

K k=1

Amlqk

=

1.

Here,

we use normalized coordinates pÀÜq

‚àà

[0, 1]2

for

the clarity of scale formulation, in which the normalized coordinates (0, 0) and (1, 1) indicate the

top-left and the bottom-right image corners, respectively. Function œÜl(pÀÜq) in Equation 3 re-scales

the normalized coordinates pÀÜq to the input feature map of the l-th level. The multi-scale deformable attention is very similar to the previous single-scale version, except that it samples LK points from

multi-scale feature maps instead of K points from single-scale feature maps.

The proposed attention module will degenerate to deformable convolution (Dai et al., 2017), when L = 1, K = 1, and Wm ‚àà RCv√óC is Ô¨Åxed as an identity matrix. Deformable convolution is designed for single-scale inputs, focusing only on one sampling point for each attention head. How-
ever, our multi-scale deformable attention looks over multiple sampling points from multi-scale in-
puts. The proposed (multi-scale) deformable attention module can also be perceived as an efÔ¨Åcient

5

variant of Transformer attention, where a pre-Ô¨Åltering mechanism is introduced by the deformable sampling locations. When the sampling points traverse all possible locations, the proposed attention module is equivalent to Transformer attention.
Deformable Transformer Encoder. We replace the Transformer attention modules processing feature maps in DETR with the proposed multi-scale deformable attention module. Both the input and output of the encoder are of multi-scale feature maps with the same resolutions. In encoder, we extract multi-scale feature maps {xl}lL=‚àí11 (L = 4) from the output feature maps of stages C3 through C5 in ResNet (He et al., 2016) (transformed by a 1 √ó 1 convolution), where Cl is of resolution 2l lower than the input image. The lowest resolution feature map xL is obtained via a 3 √ó 3 stride 2 convolution on the Ô¨Ånal C5 stage, denoted as C6. All the multi-scale feature maps are of C = 256 channels. Note that the top-down structure in FPN (Lin et al., 2017a) is not used, because our proposed multi-scale deformable attention in itself can exchange information among multi-scale feature maps. The constructing of multi-scale feature maps are also illustrated in Appendix A.2. Experiments in Section 5.2 show that adding FPN will not improve the performance.
In application of the multi-scale deformable attention module in encoder, the output are of multiscale feature maps with the same resolutions as the input. Both the key and query elements are of pixels from the multi-scale feature maps. For each query pixel, the reference point is itself. To identify which feature level each query pixel lies in, we add a scale-level embedding, denoted as el, to the feature representation, in addition to the positional embedding. Different from the positional embedding with Ô¨Åxed encodings, the scale-level embedding {el}Ll=1 are randomly initialized and jointly trained with the network.
Deformable Transformer Decoder. There are cross-attention and self-attention modules in the decoder. The query elements for both types of attention modules are of object queries. In the crossattention modules, object queries extract features from the feature maps, where the key elements are of the output feature maps from the encoder. In the self-attention modules, object queries interact with each other, where the key elements are of the object queries. Since our proposed deformable attention module is designed for processing convolutional feature maps as key elements, we only replace each cross-attention module to be the multi-scale deformable attention module, while leaving the self-attention modules unchanged. For each object query, the 2-d normalized coordinate of the reference point pÀÜq is predicted from its object query embedding via a learnable linear projection followed by a sigmoid function.
Because the multi-scale deformable attention module extracts image features around the reference point, we let the detection head predict the bounding box as relative offsets w.r.t. the reference point to further reduce the optimization difÔ¨Åculty. The reference point is used as the initial guess of the box center. The detection head predicts the relative offsets w.r.t. the reference point. Check Appendix A.3 for the details. In this way, the learned decoder attention will have strong correlation with the predicted bounding boxes, which also accelerates the training convergence.
By replacing Transformer attention modules with deformable attention modules in DETR, we establish an efÔ¨Åcient and fast converging detection system, dubbed as Deformable DETR (see Fig. 1).
4.2 ADDITIONAL IMPROVEMENTS AND VARIANTS FOR DEFORMABLE DETR
Deformable DETR opens up possibilities for us to exploit various variants of end-to-end object detectors, thanks to its fast convergence, and computational and memory efÔ¨Åciency. Due to limited space, we only introduce the core ideas of these improvements and variants here. The implementation details are given in Appendix A.4.
Iterative Bounding Box ReÔ¨Ånement. This is inspired by the iterative reÔ¨Ånement developed in optical Ô¨Çow estimation (Teed & Deng, 2020). We establish a simple and effective iterative bounding box reÔ¨Ånement mechanism to improve detection performance. Here, each decoder layer reÔ¨Ånes the bounding boxes based on the predictions from the previous layer.
Two-Stage Deformable DETR. In the original DETR, object queries in the decoder are irrelevant to the current image. Inspired by two-stage object detectors, we explore a variant of Deformable DETR for generating region proposals as the Ô¨Årst stage. The generated region proposals will be fed into the decoder as object queries for further reÔ¨Ånement, forming a two-stage Deformable DETR.
6

In the Ô¨Årst stage, to achieve high-recall proposals, each pixel in the multi-scale feature maps would serve as an object query. However, directly setting object queries as pixels will bring unacceptable computational and memory cost for the self-attention modules in the decoder, whose complexity grows quadratically with the number of queries. To avoid this problem, we remove the decoder and form an encoder-only Deformable DETR for region proposal generation. In it, each pixel is assigned as an object query, which directly predicts a bounding box. Top scoring bounding boxes are picked as region proposals. No NMS is applied before feeding the region proposals to the second stage.

5 EXPERIMENT

Dataset. We conduct experiments on COCO 2017 dataset (Lin et al., 2014). Our models are trained on the train set, and evaluated on the val set and test-dev set.
Implementation Details. ImageNet (Deng et al., 2009) pre-trained ResNet-50 (He et al., 2016) is utilized as the backbone for ablations. Multi-scale feature maps are extracted without FPN (Lin et al., 2017a). M = 8 and K = 4 are set for deformable attentions by default. Parameters of the deformable Transformer encoder are shared among different feature levels. Other hyper-parameter setting and training strategy mainly follow DETR (Carion et al., 2020), except that Focal Loss (Lin et al., 2017b) with loss weight of 2 is used for bounding box classiÔ¨Åcation, and the number of object queries is increased from 100 to 300. We also report the performance of DETR-DC5 with these modiÔ¨Åcations for a fair comparison, denoted as DETR-DC5+. By default, models are trained for 50 epochs and the learning rate is decayed at the 40-th epoch by a factor of 0.1. Following DETR(Carion et al., 2020), we train our models using Adam optimizer (Kingma & Ba, 2015) with base learning rate of 2 √ó 10‚àí4, Œ≤1 = 0.9, Œ≤2 = 0.999, and weight decay of 10‚àí4. Learning rates of the linear projections, used for predicting object query reference points and sampling offsets, are multiplied by a factor of 0.1. Run time is evaluated on NVIDIA Tesla V100 GPU.

5.1 COMPARISON WITH DETR

As shown in Table 1, compared with Faster R-CNN + FPN, DETR requires many more training epochs to converge, and delivers lower performance at detecting small objects. Compared with DETR, Deformable DETR achieves better performance (especially on small objects) with 10√ó less training epochs. Detailed convergence curves are shown in Fig. 2. With the aid of iterative bounding box reÔ¨Ånement and two-stage paradigm, our method can further improve the detection accuracy.
Our proposed Deformable DETR has on par FLOPs with Faster R-CNN + FPN and DETR-DC5. But the runtime speed is much faster (1.6√ó) than DETR-DC5, and is just 25% slower than Faster R-CNN + FPN. The speed issue of DETR-DC5 is mainly due to the large amount of memory access in Transformer attention. Our proposed deformable attention can mitigate this issue, at the cost of unordered memory access. Thus, it is still slightly slower than traditional convolution.

Table 1: Comparision of Deformable DETR with DETR on COCO 2017 val set. DETR-DC5+ denotes DETR-DC5 with Focal Loss and 300 object queries.

Method

Epochs AP AP50 AP75 APS APM APL params FLOPs FPS

Faster R-CNN + FPN

109 42.0 62.1 45.5 26.6 45.4 53.4 42M 180G 26

DETR

500 42.0 62.4 44.2 20.5 45.8 61.1 41M 86G 28

DETR-DC5

500 43.3 63.1 45.9 22.5 47.3 61.1 41M 187G 12

DETR-DC5 DETR-DC5+

50 35.3 55.7 36.8 15.2 37.5 53.6 41M 187G 12 50 36.2 57.0 37.4 16.3 39.2 53.9 41M 187G 12

Deformable DETR

50 43.8 62.6 47.7 26.4 47.1 58.0 40M 173G 19

+ iterative bounding box reÔ¨Ånement 50 45.4 64.7 49.0 26.8 48.3 61.7 40M 173G 19

++ two-stage Deformable DETR

50 46.2 65.2 50.0 28.8 49.2 61.7 40M 173G 19

5.2 ABLATION STUDY ON DEFORMABLE ATTENTION
Table 2 presents ablations for various design choices of the proposed deformable attention module. Using multi-scale inputs instead of single-scale inputs can effectively improve detection accuracy with 1.7% AP, especially on small objects with 2.9% APS. Increasing the number of sampling points

7

45 43.8 44.9 45.3

45.5

43.6

41.1

40

AP

35

30

Deformable DETR

25

DETR-DC5

50 100 150 200 2E5p0ochs300 350 400 450 500

Figure 2: Convergence curves of Deformable DETR and DETR-DC5 on COCO 2017 val set. For Deformable DETR, we explore different training schedules by varying the epochs at which the learning rate is reduced (where the AP score leaps).

K can further improve 0.9% AP. Using multi-scale deformable attention, which allows information exchange among different scale levels, can bring additional 1.5% improvement in AP. Because the cross-level feature exchange is already adopted, adding FPNs will not improve the performance. When multi-scale attention is not applied, and K = 1, our (multi-scale) deformable attention module degenerates to deformable convolution, delivering noticeable lower accuracy.

Table 2: Ablations for deformable attention on COCO 2017 val set. ‚ÄúMS inputs‚Äù indicates using multi-scale inputs. ‚ÄúMS attention‚Äù indicates using multi-scale deformable attention. K is the number of sampling points for each attention head on each feature level.

MS inputs MS attention K

FPNs

AP AP50 AP75 APS APM APL

4 FPN (Lin et al., 2017a) 43.8 62.6 47.8 26.5 47.3 58.1

4 BiFPN (Tan et al., 2020) 43.9 62.5 47.7 25.6 47.4 57.7

1

39.7 60.1 42.4 21.2 44.3 56.0

1

w/o

41.4 60.9 44.9 24.1 44.6 56.1

4

42.3 61.4 46.0 24.8 45.1 56.3

4

43.8 62.6 47.7 26.4 47.1 58.0

5.3 COMPARISON WITH STATE-OF-THE-ART METHODS
Table 3 compares the proposed method with other state-of-the-art methods. With ResNet-101 and ResNeXt-101 (Xie et al., 2017), our method achieves 48.7 AP and 49.0 AP without bells and whistles, respectively. By using ResNeXt-101 with DCN (Zhu et al., 2019b), the accuracy rises to 50.1 AP. With additional test-time augmentations, the proposed method achieves 52.3 AP.

Table 3: Comparison of Deformable DETR with state-of-the-art methods on COCO 2017 test-dev set. ‚ÄúTTA‚Äù indicates test-time augmentations including horizontal Ô¨Çip and multi-scale testing.

Method

Backbone

TTA AP AP50 AP75 APS APM APL

FCOS (Tian et al., 2019)

ResNeXt-101

44.7 64.1 48.4 27.6 47.5 55.6

ATSS (Zhang et al., 2020)

ResNeXt-101 + DCN

50.7 68.9 56.3 33.2 52.9 62.4

TSD (Song et al., 2020)

SENet154 + DCN

51.2 71.9 56.0 33.8 54.8 64.2

EfÔ¨ÅcientDet-D7 (Tan et al., 2020) EfÔ¨ÅcientNet-B6

52.2 71.4 56.3 - - -

Deformable DETR

ResNet-50

46.9 66.4 50.8 27.7 49.7 59.9

Deformable DETR

ResNet-101

48.7 68.1 52.9 29.1 51.5 62.0

Deformable DETR

ResNeXt-101

49.0 68.5 53.2 29.7 51.7 62.8

Deformable DETR

ResNeXt-101 + DCN

50.1 69.7 54.6 30.6 52.8 64.7

Deformable DETR

ResNeXt-101 + DCN

52.3 71.9 58.1 34.4 54.4 65.6

8

6 CONCLUSION
Deformable DETR is an end-to-end object detector, which is efÔ¨Åcient and fast-converging. It enables us to explore more interesting and practical variants of end-to-end object detectors. At the core of Deformable DETR are the (multi-scale) deformable attention modules, which is an efÔ¨Åcient attention mechanism in processing image feature maps. We hope our work opens up new possibilities in exploring end-to-end object detection.
ACKNOWLEDGMENTS
The work is supported by the National Key R&D Program of China (2020AAA0105200), Beijing Academy of ArtiÔ¨Åcial Intelligence, and the National Natural Science Foundation of China under grand No.U19B2044 and No.61836011.
A APPENDIX
A.1 COMPLEXITY FOR DEFORMABLE ATTENTION
Supposes the number of query elements is Nq, in the deformable attention module (see Equation 2), the complexity for calculating the sampling coordinate offsets ‚àÜpmqk and attention weights Amqk is of O(3NqCM K). Given the sampling coordinate offsets and attention weights, the complexity of computing Equation 2 is O(NqC2 + NqKC2 + 5NqKC), where the factor of 5 in 5NqKC is because of bilinear interpolation and the weighted sum in attention. On the other hand, we can also calculate Wmx before sampling, as it is independent to query, and the complexity of computing Equation 2 will become as O(NqC2 +HW C2 +5NqKC). So the overall complexity of deformable attention is O(NqC2 + min(HW C2, NqKC2) + 5NqKC + 3NqCM K). In our experiments, M = 8, K ‚â§ 4 and C = 256 by default, thus 5K + 3M K < C and the complexity is of O(2NqC2 + min(HW C2, NqKC2)).
A.2 CONSTRUCTING MULT-SCALE FEATURE MAPS FOR DEFORMABLE DETR
As discussed in Section 4.1 and illustrated in Figure 3, the input multi-scale feature maps of the encoder {xl}Ll=‚àí11 (L = 4) are extracted from the output feature maps of stages C3 through C5 in ResNet (He et al., 2016) (transformed by a 1√ó1 convolution). The lowest resolution feature map xL is obtained via a 3 √ó 3 stride 2 convolution on the Ô¨Ånal C5 stage. Note that FPN (Lin et al., 2017a) is not used, because our proposed multi-scale deformable attention in itself can exchange information among multi-scale feature maps.

Ì†µÌ±™5 Ì†µÌ∞ª 32 √ó Ì†µÌ±ä 32 √ó 2048
Ì†µÌ±™4 Ì†µÌ∞ª 16 √ó Ì†µÌ±ä 16 √ó 1024
Ì†µÌ±™3 Ì†µÌ∞ª 8 √ó Ì†µÌ±ä 8 √ó 512
ResNet Feature Maps

Ì†µÌ∞∂Ì†µÌ±úÌ†µÌ±õÌ†µÌ±£ 3 √ó 3, Ì†µÌ±†Ì†µÌ±°Ì†µÌ±üÌ†µÌ±ñÌ†µÌ±ëÌ†µÌ±í 2 Ì†µÌ∞∂Ì†µÌ±úÌ†µÌ±õÌ†µÌ±£ 1 √ó 1, Ì†µÌ±†Ì†µÌ±°Ì†µÌ±üÌ†µÌ±ñÌ†µÌ±ëÌ†µÌ±í 1 Ì†µÌ∞∂Ì†µÌ±úÌ†µÌ±õÌ†µÌ±£ 1 √ó 1, Ì†µÌ±†Ì†µÌ±°Ì†µÌ±üÌ†µÌ±ñÌ†µÌ±ëÌ†µÌ±í 1 Ì†µÌ∞∂Ì†µÌ±úÌ†µÌ±õÌ†µÌ±£ 1 √ó 1, Ì†µÌ±†Ì†µÌ±°Ì†µÌ±üÌ†µÌ±ñÌ†µÌ±ëÌ†µÌ±í 1

Ì†µÌ∞ª 64 √ó Ì†µÌ±ä 64 √ó 256 Ì†µÌ∞ª 32 √ó Ì†µÌ±ä 32 √ó 256 Ì†µÌ∞ª 16 √ó Ì†µÌ±ä 16 √ó 256
Ì†µÌ∞ª 8 √ó Ì†µÌ±ä 8 √ó 256 Input Multi-Scale FeatureMaps {Ì†µÌ≤ôÌ†µÌ±ô}Ì†µ4Ì±ô=1

Figure 3: Constructing mult-scale feature maps for Deformable DETR.

A.3 BOUNDING BOX PREDICTION IN DEFORMABLE DETR
Since the multi-scale deformable attention module extracts image features around the reference point, we design the detection head to predict the bounding box as relative offsets w.r.t. the reference

9

point to further reduce the optimization difÔ¨Åculty. The reference point is used as the initial guess
of the box center. The detection head predicts the relative offsets w.r.t. the reference point pÀÜq = (pÀÜqx, pÀÜqy), i.e., bÀÜq = {œÉ bqx+œÉ‚àí1(pÀÜqx) , œÉ bqy +œÉ‚àí1(pÀÜqy) , œÉ(bqw), œÉ(bqh)}, where bq{x,y,w,h} ‚àà R are predicted by the detection head. œÉ and œÉ‚àí1 denote the sigmoid and the inverse sigmoid function, respectively. The usage of œÉ and œÉ‚àí1 is to ensure bÀÜ is of normalized coordinates, as bÀÜq ‚àà [0, 1]4. In this way, the learned decoder attention will have strong correlation with the predicted
bounding boxes, which also accelerates the training convergence.

A.4 MORE IMPLEMENTATION DETAILS

Iterative Bounding Box ReÔ¨Ånement. Here, each decoder layer reÔ¨Ånes the bounding boxes based
on the predictions from the previous layer. Suppose there are D number of decoder layers (e.g., D = 6), given a normalized bounding box bÀÜdq‚àí1 predicted by the (d ‚àí 1)-th decoder layer, the d-th decoder layer reÔ¨Ånes the box as

bÀÜdq = {œÉ(‚àÜbdqx+œÉ‚àí1(ÀÜbdqx‚àí1)), œÉ(‚àÜbdqy+œÉ‚àí1(ÀÜbqdy‚àí1)), œÉ(‚àÜbdqw+œÉ‚àí1(ÀÜbqdw‚àí1)), œÉ(‚àÜbdqh+œÉ‚àí1(ÀÜbqdh‚àí1))},

where d ‚àà {1, 2, ..., D}, ‚àÜbdq{x,y,w,h} ‚àà R are predicted at the d-th decoder layer. Prediction
heads for different decoder layers do not share parameters. The initial box is set as ÀÜb0qx = pÀÜqx, ÀÜb0qy = pÀÜqy, ÀÜb0qw = 0.1, and ÀÜb0qh = 0.1. The system is robust to the choice of b0qw and b0qh. We tried setting them as 0.05, 0.1, 0.2, 0.5, and achieved similar performance. To stabilize training, similar to Teed & Deng (2020), the gradients only back propagate through ‚àÜbdq{x,y,w,h}, and are blocked at
œÉ‚àí1(ÀÜbdq{‚àíx1,y,w,h}).

In iterative bounding box reÔ¨Ånement, for the d-th decoder layer, we sample key elements respective to the box bÀÜdq‚àí1 predicted from the (d ‚àí 1)-th decoder layer. For Equation 3 in the cross-attention module of the d-th decoder layer, (ÀÜbqdx‚àí1, ÀÜbqdy‚àí1) serves as the new reference point. The sampling offset ‚àÜpmlqk is also modulated by the box size, as (‚àÜpmlqkx ÀÜbdqw‚àí1, ‚àÜpmlqky ÀÜbqdh‚àí1). Such modiÔ¨Åcations make the sampling locations related to the center and size of previously predicted boxes.

Two-Stage Deformable DETR. In the Ô¨Årst stage, given the output feature maps of the encoder, a detection head is applied to each pixel. The detection head is of a 3-layer FFN for bounding box regression, and a linear projection for bounding box binary classiÔ¨Åcation (i.e., foreground and background), respectively. Let i index a pixel from feature level li ‚àà {1, 2, ..., L} with 2-d normalized coordinates pÀÜi = (pÀÜix, pÀÜiy) ‚àà [0, 1]2, its corresponding bounding box is predicted by

bÀÜi = {œÉ(‚àÜbix + œÉ‚àí1(pÀÜix)), œÉ(‚àÜbiy + œÉ‚àí1(pÀÜiy)), œÉ(‚àÜbiw + œÉ‚àí1(2li s)), œÉ(‚àÜbih + œÉ‚àí1(2li s))},

where the base object scale s is set as 0.05, ‚àÜbi{x,y,w,h} ‚àà R are predicted by the bounding box regression branch. The Hungarian loss in DETR is used for training the detection head.

Given the predicted bounding boxes in the Ô¨Årst stage, top scoring bounding boxes are picked as region proposals. In the second stage, these region proposals are fed into the decoder as initial boxes for the iterative bounding box reÔ¨Ånement, where the positional embeddings of object queries are set as positional embeddings of region proposal coordinates.

Initialization for Multi-scale Deformable Attention. In our experiments, the number of at-

tention heads is set as M = 8. In multi-scale deformable attention modules, Wm ‚àà RCv√óC and Wm ‚àà RC√óCv are randomly initialized. Weight parameters of the linear projection for

predicting Amlqk and ‚àÜpmlqk are initialized to zero. Bias parameters of the linear projection

are initialized to make Amlqk

=

1 LK

and {‚àÜp1lqk

=

(‚àík, ‚àík), ‚àÜp2lqk

=

(‚àík, 0), ‚àÜp3lqk

=

(‚àík, k), ‚àÜp4lqk = (0, ‚àík), ‚àÜp5lqk = (0, k), ‚àÜp6lqk = (k, ‚àík), ‚àÜp7lqk = (k, 0), ‚àÜp8lqk =

(k, k)} (k ‚àà {1, 2, ...K}) at initialization.

For iterative bounding box reÔ¨Ånement, the initialized bias parameters for ‚àÜpmlqk prediction in the

decoder

are

further

multiplied

with

1 2K

,

so

that

all

the

sampling

points

at

initialization

are

within

the

corresponding bounding boxes predicted from the previous decoder layer.

10

REFERENCES
Joshua Ainslie, Santiago Ontanon, Chris Alberti, Philip Pham, Anirudh Ravula, and Sumit Sanghai. Etc: Encoding long and structured data in transformers. arXiv preprint arXiv:2004.08483, 2020.
Iz Beltagy, Matthew E Peters, and Arman Cohan. Longformer: The long-document transformer. arXiv preprint arXiv:2004.05150, 2020.
Nicolas Carion, Francisco Massa, Gabriel Synnaeve, Nicolas Usunier, Alexander Kirillov, and Sergey Zagoruyko. End-to-end object detection with transformers. In ECCV, 2020.
Rewon Child, Scott Gray, Alec Radford, and Ilya Sutskever. Generating long sequences with sparse transformers. arXiv preprint arXiv:1904.10509, 2019.
Krzysztof Choromanski, Valerii Likhosherstov, David Dohan, Xingyou Song, Jared Davis, Tamas Sarlos, David Belanger, Lucy Colwell, and Adrian Weller. Masked language modeling for proteins via linearly scalable long-context transformers. arXiv preprint arXiv:2006.03555, 2020.
Jifeng Dai, Haozhi Qi, Yuwen Xiong, Yi Li, Guodong Zhang, Han Hu, and Yichen Wei. Deformable convolutional networks. In ICCV, 2017.
Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. Imagenet: A large-scale hierarchical image database. In CVPR, 2009.
Golnaz Ghiasi, Tsung-Yi Lin, and Quoc V Le. Nas-fpn: Learning scalable feature pyramid architecture for object detection. In CVPR, 2019.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In CVPR, 2016.
Jonathan Ho, Nal Kalchbrenner, Dirk Weissenborn, and Tim Salimans. Axial attention in multidimensional transformers. arXiv preprint arXiv:1912.12180, 2019.
Han Hu, Zheng Zhang, Zhenda Xie, and Stephen Lin. Local relation networks for image recognition. In ICCV, 2019.
Zilong Huang, Xinggang Wang, Lichao Huang, Chang Huang, Yunchao Wei, and Wenyu Liu. Ccnet: Criss-cross attention for semantic segmentation. In ICCV, 2019.
Angelos Katharopoulos, Apoorv Vyas, Nikolaos Pappas, and Franc¬∏ois Fleuret. Transformers are rnns: Fast autoregressive transformers with linear attention. arXiv preprint arXiv:2006.16236, 2020.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In ICLR, 2015.
Nikita Kitaev, ≈Åukasz Kaiser, and Anselm Levskaya. Reformer: The efÔ¨Åcient transformer. In ICLR, 2020.
Tao Kong, Fuchun Sun, Chuanqi Tan, Huaping Liu, and Wenbing Huang. Deep feature pyramid reconÔ¨Åguration for object detection. In ECCV, 2018.
Tsung-Yi Lin, Michael Maire, Serge Belongie, James Hays, Pietro Perona, Deva Ramanan, Piotr Dolla¬¥r, and C Lawrence Zitnick. Microsoft coco: Common objects in context. In ECCV, 2014.
Tsung-Yi Lin, Piotr Dolla¬¥r, Ross Girshick, Kaiming He, Bharath Hariharan, and Serge Belongie. Feature pyramid networks for object detection. In CVPR, 2017a.
Tsung-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, and Piotr Dolla¬¥r. Focal loss for dense object detection. In ICCV, 2017b.
Li Liu, Wanli Ouyang, Xiaogang Wang, Paul Fieguth, Jie Chen, Xinwang Liu, and Matti Pietika¬®inen. Deep learning for generic object detection: A survey. IJCV, 2020.
Peter J Liu, Mohammad Saleh, Etienne Pot, Ben Goodrich, Ryan Sepassi, Lukasz Kaiser, and Noam Shazeer. Generating wikipedia by summarizing long sequences. In ICLR, 2018a.
11

Shu Liu, Lu Qi, Haifang Qin, Jianping Shi, and Jiaya Jia. Path aggregation network for instance segmentation. In CVPR, 2018b.
Niki Parmar, Ashish Vaswani, Jakob Uszkoreit, ≈Åukasz Kaiser, Noam Shazeer, Alexander Ku, and Dustin Tran. Image transformer. In ICML, 2018.
Niki Parmar, Prajit Ramachandran, Ashish Vaswani, Irwan Bello, Anselm Levskaya, and Jon Shlens. Stand-alone self-attention in vision models. In NeurIPS, 2019.
Jiezhong Qiu, Hao Ma, Omer Levy, Scott Wen-tau Yih, Sinong Wang, and Jie Tang. Blockwise self-attention for long document understanding. arXiv preprint arXiv:1911.02972, 2019.
Shaoqing Ren, Kaiming He, Ross Girshick, and Jian Sun. Faster r-cnn: Towards real-time object detection with region proposal networks. In NeurIPS, 2015.
Aurko Roy, Mohammad Saffar, Ashish Vaswani, and David Grangier. EfÔ¨Åcient content-based sparse attention with routing transformers. arXiv preprint arXiv:2003.05997, 2020.
Guanglu Song, Yu Liu, and Xiaogang Wang. Revisiting the sibling head in object detector. In CVPR, 2020.
Mingxing Tan, Ruoming Pang, and Quoc V Le. EfÔ¨Åcientdet: Scalable and efÔ¨Åcient object detection. In CVPR, 2020.
Yi Tay, Dara Bahri, Liu Yang, Donald Metzler, and Da-Cheng Juan. Sparse sinkhorn attention. In ICML, 2020a.
Yi Tay, Mostafa Dehghani, Dara Bahri, and Donald Metzler. EfÔ¨Åcient transformers: A survey. arXiv preprint arXiv:2009.06732, 2020b.
Zachary Teed and Jia Deng. Raft: Recurrent all-pairs Ô¨Åeld transforms for optical Ô¨Çow. In ECCV, 2020.
Zhi Tian, Chunhua Shen, Hao Chen, and Tong He. Fcos: Fully convolutional one-stage object detection. In ICCV, 2019.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, ≈Åukasz Kaiser, and Illia Polosukhin. Attention is all you need. In NeurIPS, 2017.
Sinong Wang, Belinda Li, Madian Khabsa, Han Fang, and Hao Ma. Linformer: Self-attention with linear complexity. arXiv preprint arXiv:2006.04768, 2020.
Felix Wu, Angela Fan, Alexei Baevski, Yann N Dauphin, and Michael Auli. Pay less attention with lightweight and dynamic convolutions. In ICLR, 2019.
Saining Xie, Ross Girshick, Piotr Dolla¬¥r, Zhuowen Tu, and Kaiming He. Aggregated residual transformations for deep neural networks. In CVPR, 2017.
Hang Xu, Lewei Yao, Wei Zhang, Xiaodan Liang, and Zhenguo Li. Auto-fpn: Automatic network architecture adaptation for object detection beyond classiÔ¨Åcation. In ICCV, 2019.
Manzil Zaheer, Guru Guruganesh, Avinava Dubey, Joshua Ainslie, Chris Alberti, Santiago Ontanon, Philip Pham, Anirudh Ravula, Qifan Wang, Li Yang, et al. Big bird: Transformers for longer sequences. arXiv preprint arXiv:2007.14062, 2020.
Shifeng Zhang, Cheng Chi, Yongqiang Yao, Zhen Lei, and Stan Z Li. Bridging the gap between anchor-based and anchor-free detection via adaptive training sample selection. In CVPR, 2020.
Qijie Zhao, Tao Sheng, Yongtao Wang, Zhi Tang, Ying Chen, Ling Cai, and Haibin Ling. M2det: A single-shot object detector based on multi-level feature pyramid network. In AAAI, 2019.
Xizhou Zhu, Dazhi Cheng, Zheng Zhang, Stephen Lin, and Jifeng Dai. An empirical study of spatial attention mechanisms in deep networks. In ICCV, 2019a.
Xizhou Zhu, Han Hu, Stephen Lin, and Jifeng Dai. Deformable convnets v2: More deformable, better results. In CVPR, 2019b.
12

